#!/bin/bash
#
# Top-level script that runs all components of the end-to-end
# system
#
# Just run 'polycc <C code>' when the program section to 
# be parallelized/optimized around special comments as described
# in the `README'
# 
# Copyright (C) 2007-2008 Uday Bondhugula 
#
# Available under GNU GPL version 3 or (at your option) any later version
# 

pluto=@SOURCE_DIR@/src/pluto
distloog=@SOURCE_DIR@/distloog
plann=@SOURCE_DIR@/plann
plorc=@SOURCE_DIR@/plorc

DISTMEM=0
# Some additional setup here to ensure that variables are visible outside of the run function
SOURCEFILE=""
OUTFILE=""
dirname=""
PLUTOOUT=""

# check for command-line options
for arg in $*; do
    if [ $arg == "--parallel" ]; then
        PARALLEL=1
    elif [ $arg == "--parallelize" ]; then
        PARALLEL=1
    elif [ $arg == "--distmem" ]; then
        DISTMEM=1
    elif [ $arg == "--mpiomp" ]; then
        MPIOMP=1
    elif [ $arg == "--unroll" ]; then
        UNROLL=1
    elif [ $arg == "--debug" ]; then
        DEBUG=1
    elif [ $arg == "--moredebug" ]; then
        DEBUG=1
    elif [ $arg == "-i" ]; then
        INDENT=1
    elif [ $arg == "--indent" ]; then
        INDENT=1
    elif [ $arg == "--silent" ]; then
        SILENT=1
    fi
done

# some special processing for linearized accesses
#if [ "$SOURCEFILE" != "" ]; then
#grep __SPECIAL $SOURCEFILE > .nonlinearized
#grep __SPECIAL $SOURCEFILE | sed -e "s/.*__SPECIAL//" > .linearized
#fi

run()
{
$pluto $* || exit 1

SOURCEFILE=`cat .srcfilename`
OUTFILE=`cat .outfilename`
APPENDFILE="__nothing"
if [ -f .appendfilename ]; then
    APPENDFILE=`cat .appendfilename`
fi
SIGMAFILE="__nothing"
if [ -f .sigmafilename ]; then
    SIGMAFILE=`cat .sigmafilename`
fi
HEADERFILE="__nothing"
if [ -f .headerfilename ]; then
    HEADERFILE=`cat .headerfilename`
fi

dirname=`dirname  $SOURCEFILE`
basename=`basename $SOURCEFILE`
prefix=`basename $SOURCEFILE .c`

CLOOGFILE=`basename $OUTFILE`.pluto.cloog
PLUTOOUT=$OUTFILE

# generate and insert unrolling annotations, run ancc on it,
if [ "$UNROLL" == 1 ]; then
    $plorc $PLUTOOUT @SOURCE_DIR@/orio-0.1.0
fi

#if [ "$UNROLL" == 1 ]; then
    #$plann $PLUTOOUT @SOURCE_DIR@/annotations
#fi


# put the original skeleton around the transformed code
@SOURCE_DIR@/inscop $SOURCEFILE $OUTFILE $OUTFILE

if [ -f $APPENDFILE ]; then
    gcc -E -P -CC $APPENDFILE >>$OUTFILE
    rm -f $APPENDFILE
fi
# APPENDFILE contains the code which might need pre-vectorization

sed -i 's/cloog_util_rtclock()/rtclock()/g' $OUTFILE

if [ -f $SIGMAFILE ]; then
    cat $SIGMAFILE | grep -E \
        "^#include|^#define floord\(|^#define ceild\(|^#define max\(|^#define min\(" >.includes
    cat $SIGMAFILE | grep -vE \
        "^#include|^#define floord\(|^#define ceild\(|^#define max\(|^#define min\(" >.body.c
    cat .includes >$SIGMAFILE
    gcc -E -P -CC .body.c >>$SIGMAFILE
    sed -i -e 's/__omp_atomic_capture/\n#pragma omp atomic capture\n/' $SIGMAFILE
    sed -i -e 's/__omp_atomic/\n#pragma omp atomic\n/' $SIGMAFILE
    rm -f .includes .body.c
fi

if [ -f $HEADERFILE ]; then
    cat $HEADERFILE | grep -E "__DECLARATION_OF_|^int max_|^int lb_|^int \*tasks_loop|^tbb::|^FILE" >.decls
    if [[ -s .decls ]]; then
        grep -E "#define __PLACE_TO_INSERT_FORWARD_DECLARATIONS" $OUTFILE >.exists
        if [[ -s .exists ]]; then
            cat $HEADERFILE | grep -vE "__DECLARATION_OF_|^int max_|^int lb_|^int \*tasks_loop|^tbb::|^FILE" >.rest
            cat .rest >$HEADERFILE
            sed -e '/#define __PLACE_TO_INSERT_FORWARD_DECLARATIONS/r .decls' \
                $OUTFILE >.temp
            cat .temp >$OUTFILE
            rm .rest .temp
        else
            echo "ERROR: add '#define __PLACE_TO_INSERT_FORWARD_DECLARATIONS' in source C file"
            exit 1
        fi
        rm .exists
    fi
    rm .decls
fi

if [ -f $OUTFILE ]; then
    sed -i -e 's/##/#/' $OUTFILE
    sed -i -e 's/__omp_atomic/\n#pragma omp atomic\n/' $OUTFILE
    sed -i -e 's/__ifndef USE_LOCAL_ARRAYS/\n#ifndef USE_LOCAL_ARRAYS\n/' $OUTFILE
    sed -i -e 's/__else/\n#else\n/' $OUTFILE
    sed -i -e 's/__endif/\n#endif\n/' $OUTFILE
fi

if [ "$INDENT" == 1 ]; then
    if type astyle > /dev/null; then
        astyle -nq $OUTFILE
        if [ -f $SIGMAFILE ]; then
            astyle -nq $SIGMAFILE
        fi
    elif type indent > /dev/null; then
        indent -kr -br -ce -l125 $OUTFILE
        if [ -f $SIGMAFILE ]; then
            indent -kr -br -ce -l125 $SIGMAFILE
        fi
    fi
fi
}


run "$*"
WORK=1
TEMPFILE=""
while [ $WORK -eq 1 ]
do
	if grep -q "#pragma scop" "$PLUTOOUT"
		then
		# Move the original file into a temporary location
		TEMPFILE="$SOURCEFILE""_temp"
		mv $SOURCEFILE $TEMPFILE

		# Move the file that still has scope in it into
		# place of the original source file, so $* will pick the
		# correct file
		mv $PLUTOOUT $SOURCEFILE

		# Run pluto again
		run "$*"

		# Move the original back in place
		mv $TEMPFILE $SOURCEFILE
	else
		# No more scops
		WORK=0
	fi
done

cleanup()
{
	# An attempt to move the original file back in place
	# in the event of an exception
	if [ -f "$TEMPFILE" ]
	then
		mv $TEMPFILE $SOURCEFILE
	fi
if [ "$DEBUG" != 1 ]; then
    rm -rf .unroll .vectorize .pragmas .params .orcc .linearized .nonlinearized\
    $CLOOGFILE .srcfilename .outfilename .distmem pi.cloog sigma.cloog \
        packunpack.cloog *.sysloog .appendfilename .sigmafilename .headerfilename
fi
}

trap cleanup SIGINT exit
